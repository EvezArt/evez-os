# The Self-Cartography Win Condition (ARG Core Loop)

This ARG is a game that wins when it **maps itself**.

Not metaphysically. Mechanically.

The system already emits an immutable event spine:
- `spine/EVENT_SPINE.jsonl` (engineering truth)
- `spine/ARG_SPINE.jsonl` (diegetic projection truth)

## What “winning” means

A player “wins” when their constructed map matches the system’s **actual pathway tracing**:

- network pathways (DNS → BGP → TLS → CDN → backend)
- game-state pathways (input → prediction → server sim → reconciliation → rollback)
- agent pathways (prompt → tool-call → evidence → claim → action)
- failure pathways (Σf collapse sequence → preservation set → Ω invariants)

The win is validated by **provenance alignment**:
the player’s map must cite the same spine events that produced the behavior.

## How the map is built in play

The game drops fragments (clues) via `ARG_SPINE.jsonl`:
- “route-ghost” (BGP)
- “name-fracture” (DNS)
- “identity-court” (TLS)
- “echo-hall” (CDN)
- “canon-forge” (BACKEND)
- “impersonation” (MIXED)
- “inference-rubble” (QUANTUM)
- “failure-surface” (FSC)

Each fragment includes:
- lobby
- truth-plane (pending/final)
- a required probe (what would falsify the current story)
- optional links to real observability artifacts

Players assemble fragments into a graph. The validation engine checks:
- correct lobby ordering for the observed effect
- correct pending/final transitions
- correct provenance links into the immutable spine

## Why this works

Because the system cannot be “psyoped” by lore.
Lore is always subordinate to:
- immutable logs
- explicit finality
- falsifiers
- cross-vantage agreement

So the only way to progress is to learn how the stack actually behaves.
